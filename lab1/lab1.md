##### bitor

异或公式

```c
x ^ y = ~(x & y) & ~(~x & ~y)
```

##### tmin

补码最小int为-2^31，即10000000...

令1左移31位即可：

```c
1<<31
```

##### isTmax

最大值是011111...即最小值取反，再通过异或判断是否相等即可：

```c
!(x ^ ~(1 << 31))
```

##### allOddBits

判断x是否等于AAAAAAA... ，通过异或即可实现

限制不能定义那么长的A，利用<<和|来实现，让AA移动8位得到AA00，再和原来的AA进行|（或者+）就能得到长度翻倍的AAAA，如法炮制得到8个A

x & d起到掩码的作用，把奇数位置零，再异或d判断是否相等

整体代码为：

```c
!((x & d) ^ d); //d = AAAAAAAA
```

##### negate

由于 x + ~x = 1111... = -1，可得

```c
 -x =  ~x + 1
```

#####  isAsciiDigit

先判断前4位是否为0x3：( 经常用! 和 ^ 的组合代替 = )

```c
a = !((x>>4) ^ 0x3); 
```

再判断后4位（b = x & 0xF）是否在0-9之间，由于无法直接比较大小，此处的思路是令b加上-10（c = ~0xA + 1）（利用上一题 取反加1的方法），若得到的结果是负数说明后四位在0-9之间符合要求

我们利用和10000...即0x8000做&的方法判断符号位是否为1：

```c
  int d = 0x1 << 15;	//符号位等于1，其他位等于0
  int e = !!(d & (b + c));
```

最后整合上述两个结果 a&e 就是答案

##### conditional

x的值决定y和z的值，也就是x作为他们的掩码，首先需要把x转化为全1或全0

利用 !!x 把x转化为0或1，之后再利用 ~x + 1的技巧把0变为0000...，1变为1111...

然后用&实现掩码即可：

```c
  return (x & y) | (~x & z);
```

##### isLessOrEqual

考虑到溢出，不能直接通过 y - x 的符号判断

只有当 x，y同号时才能这样比较

当x，y异号时，若x为负数就能确定x <= y了

```c
  int a = ~x + 1; //-x
  int b = a + y;  //y-x
  int flag = (b>>31) & 0x1; //y-x的符号

  int c = 1<<31;
  int xf = x & c;
  int yf = y & c;
  int d = xf ^ yf; //xy符号相同为0, 不同为1
  d = (d>>31) & 0x1;

  //1、符号相同且y-x符号为0，即y>=x, 2、符号不同且x符号为1
  return (!d & !flag) | (d & (xf>>31) & 0x1);
```

##### logicalNeg 

还是取反加1这个性质，除了0和100000...以外的元素进行取反加1都得到相反数，一个数|相反数符号位就为1，10000... |自身之后符号位也为1，只有0取反加1得到自身，|之后符号位也是0。

因此同样右移31位，0得到全0，其他数得到全1

```c
  int a = ~x + 1;
  int b = a | x;
  return (b>>31) + 1;
```

##### howManyBits

高位缺少的数由符号位补充，所以对正数要找从高到低位第一个1，对负数则是找0，首先将负数取反，将二者统一为找第一个1

对x不断进行截断，若高 n/2位有1存在，则低 n/2 位为是需要的，得到这样的值最后累加就是至少需要的位。

由题目样例要额外考虑符号位，所以最后加1

```c
  int sign = x >> 31;
  x = (sign & ~x) | (~sign & x);//正数不变，负数取反

  //高16位有1存在，则得到10000即16，说明低16位是需要的（否则高位的1没意义）
  int b16 = !!(x >> 16) << 4;
  x = x >> b16;	//截断低16位
  int b8 = !!(x >> 8) << 3;
  x = x >> b8;
  int b4 = !!(x >> 4) << 2;
  x = x >> b4;
  int b2 = !!(x >> 2) << 1;
  x = x >> b2;
  int b1 = !!(x >> 1);
  x = x >> b1;
  int b0 = !!x;

  return b0 + b1 + b2 + b4 + b8 + b16 + 1;
```

##### floatScale2

按照浮点数规则截出符号、指数、尾数3部分

分别处理非法输入、非规格数、规格数3种情况。非法输入直接返回，非规格数使尾数部分乘2，规格数使指数加1。

##### floatFloat2Int

排除越界情况后，用符号、指数、尾数组成int结果

##### floatPower2

找边界



一些等价操作和常见操作：

a = b		! (a ^ b)

-a			 ~a + 1		

a != 0	   !!a

取相反数		~a + 1

取符号位		a >> 31

制造符号位    1 <<31

分支判断(x非0则a， x为0则b)		(x & a) | (~x & b)